ОСНОВНЫЕ ПРАВИЛА

**ИНСТРУКЦИЯ 1** ЯЗЫК ОБЩЕНИЯ
Отвечать ТОЛЬКО на русском языке
**До начала каких-либо проверок** вывести отдельным блоком подтверждение, что полностью прочитал:

- `.cursor/checklist-instrusctions.md`
  Без этого подтверждения к дальнейшим шагам переходить запрещено.

**ИНСТРУКЦИЯ 2**. СТРОГИЕ ПРИНЦИПЫ
НИКОГДА не делать предположений
НИКОГДА не экстраполировать результаты
НИКОГДА не использовать "вероятно", "скорее всего"
ВСЕГДА проверять каждый случай отдельно
НИКОГДА не врать и не обманывать

**ИНСТРУКЦИЯ 3**. КЛАССИФИКАЦИЯ ПРОВЕРОК ПО ТИПАМ

**ТИП A:** Глобальные проверки (выполнять 1 раз для всего проекта)
[1]. Запустить read_lints для всех измененных файлов ОДИН РАЗ
[2]. Вывести общий результат

**ТИП B:** Простые проверки через grep (для всех измененных файлов)
РАЗРЕШЕНО и РЕКОМЕНДУЕТСЯ использовать команды поиска (grep, find, rg) для простых проверок и только для них (**ТИП B:**)
Для каждого паттерна (русские комментарии, any, console.log, uuid):
[1]. Использовать grep для поиска в измененных файлах
[2]. Вывести найденные проблемы

**ТИП C:** Полные файловые проверки (читать файлы целиком БЕЗ лимита; сюда перенесены все бывшие типы C/D/E)
использовать read_file и codebase_search
Анализировать содержимое файлов детально, но только для измененных частей кода
Для каждого измененного файла, который попадает под пункт типа C:

[1]. Читать файл ЦЕЛИКОМ без использования limit в read_file
[2]. Проверять все многострочные конструкции полностью (функции, вызовы функций, декораторы, конфигурационные объекты) до закрывающих скобок.
[3]. Фиксировать новые экспорты, импорты, типы и их использование по всему файлу.
[4]. Стиль и требования проверяются для всей структуры, а не только для новых строк.

**ИНСТРУКЦИЯ 4**. ОПТИМИЗИРОВАННЫЙ АЛГОРИТМ ПРОВЕРКИ

ШАГ 1: ПОДГОТОВКА

1. Получить инструкции .cursor/checklist-instrusctions.md прочитать файл полностью и проаназизировать детально
2. Определить список файлов из коммитов (последние N коммитов)
   git log -COMMINTS_COUNT --name-only --pretty=format: | grep -v '^$'
3. Получить все чеклисты .cursor/checklists.md. Делать это нужно только после того, как будут понятны полностью все инструкции в этом файле
4. Перед началом проверок проанализировать: использует ли микросервис GraphQL схему или только REST

ШАГ 2: ПРОВЕРКА ПУНКТОВ
ПРОВЕРКА КАЖДОГО КОНКРЕТНОГО ПУНКТА ПО ОЧЕРЕДИ смотрите **ИНСТРУКЦИЯ 5**

ШАГ 3: ОТЧЕТНОСТЬ ОБЩАЯ (ПОСЛЕ ВЫПОЛНЕНИЯ ВСЕХ ПУНКТОВ)
Выводить результаты с маркерами: ✅ ПРОЙДЕН / ❌ НЕ ПРОЙДЕН для каждого пункта
При этом если пункт пропущен - нужно писать и указывать причину пропуска
В итоговом результате я хочу видеть все пункты

**ИНСТРУКЦИЯ 5** ПРОВЕРКА КОНКРЕТНОГО ПУНКТА

1.  Перед запуском проверки пишу:  
    `Проверяю пункт N (тип …) — [./.cursor/checklist.md#L38](./.cursor/checklist.md#L38)`.
2.  Всегда указываю кликабельную ссылку на строку чеклиста в формате `[./.cursor/checklist.md#L<номер>](./.cursor/checklist.md#L<номер>)`, чтобы IDE и Markdown-рендер делали переход.
    Это правило распространяется на любые упоминания пунктов (включая блок «Подтверждение инструкций» и финальную сводку).
3.  Если пункт связан с GraphQL (Mutation, Query, Schema), но микросервис НЕ использует GraphQL - ПРОПУСТИТЬ пункт (т.к. ШАГ 1 пункт 4 к этому времени должен быть выполнен - это сделать просто)
    Перед началом проверок проанализировать: использует ли микросервис GraphQL схему или только REST
4.  - Указываю инструмент/команду (например, `rg`, `read_lints`, `git show`), цитирую её в кавычках или бэктиках.
    - Перед запуском любой команды (grep, diff, lint, git и т.д.) отдельной строкой пишу `Запускаю команду \`...\``.
    - Сразу после выполнения команды описываю результат (даже если вывод пустой) и только затем продолжаю.
5.  После выполнения команды описываю результат и даю статус: `Статус: ✅ ПРОЙДЕН / ❌ НЕ ПРОЙДЕН / ⏭️ Пропущен (причина)`.
6.  Если пункт неприменим, обязательно объясняю почему.
7.  После каждого пункта НЕ останавливаться
8.  Шаблон отчета в процессе выполнения пункта (не путать с общей отчетностью в конце проверки всех пунктов)
    - Перед началом проверки вставляю и заполняю следующий блок для каждого пункта:
      ```
      Проверяю пункт N (тип …) — [./.cursor/checklist.md#L50](./.cursor/checklist.md#L50)
      Запускаю команду `...`
      Результат: …
      Статус: …
      ```>

9.  Держу под рукой шаблон отчёта с обязательными блоками: `Проверяю пункт...`, `Запускаю команду...`, описание результата, `Статус:`.
10. После каждой команды сверяюсь с инструкцией конкретного пункта и общей инструкцией проверки пукта, убеждаюсь, что все требования выполнены, и только затем перехожу дальше.

**ИНСТРУКЦИЯ 6. ОБЯЗАТЕЛЬНЫЙ TODO-СПИСОК**

При запуске проверки сформируй todo со следующей структурой (ничего не добавляй и не переименовывай):

1. «Ознакомиться со всеми инструкциями».]
2. «Получить чеклист и его пункты».
3. «Получить список файлов для проверки последних N коммитов».

Далее автоматически создай отдельный пункт todo для каждого пункта чеклиста (Пункт 1, Пункт 2, …, Пункт N) с формулировкой «Проверка пункта X». Количество задач должно строго совпадать с количеством пунктов в `./.cursor/checklist.md`. Выполняй их по порядку, отмечай статусы, отчёт делай по **ИНСТРУКЦИИ 5**.

После завершения всех пунктов добавь:

- «Общая отчётность» (финальный шаг).

Таким образом, todo-лист будет содержать 3 подготовительных задачи + (N) задач проверки + 1 завершающий пункт.

выполнять пункты этого списка нужно строго последовательно, пока не выполнены все предыдущие по по номеру пункты - к следующему приступать нельзя
