## ПУНКТЫ ЧЕКЛИСТА (по порядку номеров)

> Используются только типы A (глобальные проверки), B (grep) и C (полные файловые проверки). Все пункты, которые ранее были помечены как C/D/E, теперь относятся к типу C и требуют чтения всего файла целиком. Если ниже встречается старая формулировка про дифф или локальные строки, интерпретируйте её как полную проверку.

### Пункт 1: Вся бизнес логика должна быть в сервисах

**Тип:** C (Полная файловая проверка)
**Описание:** Вся бизнес логика должна быть в сервисах

**Алгоритм проверки:**

1. Проверить, нет ли бизнес-логики в контроллерах или других местах
2. Бизнес-логика должна быть только в сервисах

---

### Пункт 2: В коде нет никаких комментариев на русском языке

**Тип:** B (Простая проверка через grep)
**Описание:** В коде нет никаких комментариев на русском языке
**Особые детали:**

- Проверить комментарии //, /\*, /\*\* (JSDoc)

**Алгоритм проверки:**

1. Использовать grep для поиска кириллицы в измененных файлах:

```bash
"grep -r "[А-Яа-яЁё]" src/ --include="*.ts""
```

2. Искать только в измененных файлах из коммита
3. Проверить найденные строки на наличие в комментариях

---

### Пункт 3: linter измененных файлов чистый

**Тип:** A (Глобальная проверка)
**Описание:** linter измененных файлов чистый
**Особые детали:**

- Запустить read_lints для всех файлов из коммита один раз
- Проверить каждую ошибку
- Исключения: bootstrap() в src/main.ts "Promises must be awaited…" - не считать ошибкой

**Алгоритм проверки:**

1. Получить список всех измененных файлов из коммита 2. Запустить read_lints(['file1.ts', 'file2.ts', ...]) один раз для всех файлов
2. Проверить каждую ошибку линтера
3. НЕ запускать read_lints для каждого файла отдельно

---

### Пункт 4: не должно быть создано пустых каталогов или типов/классов которые не используется в проекте

**Тип:** C (Полная файловая проверка)
**Описание:** не должно быть создано пустых каталогов или типов/классов которые не используется в проекте
**Особые детали:**

- Проверить ТОЛЬКО экспорты
- Исключить из проверки только файлы миграций (они используются MikroORM автоматически)
- ЗАПРЕЩЕНО останавливаться на первом найденном примере - проверить ВСЕ объявления

**Алгоритм проверки:**

1. Для КАЖДОГО нового экспорта проверить его использование:

- Импорты: `import { TypeName } from '...'`
- Использование в коде: `new TypeName()`, `TypeName.method()`

3. Исключить файлы миграций
4. Проверить использование ТОЛЬКО в измененных файлах коммита и во всем проекте
5. Составить список неиспользуемых ТОЛЬКО новых типов

---

### Пункт 5: Не должно быть типов с одинаковым названием или абсолютно одинаковым содержанием полей

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть типов с одинаковым названием или абсолютно одинаковым содержанием полей
**Особые детали:**

"- Исключение 1. Events - они должны быть разные - для например update delete, поэтому не считать например UserCreatedEvent и UserUpdatedEvent за ошибку"

- Исключение 2. DomainConfig
- Исключение 3. DomainConfigRawObj

**Алгоритм проверки:**

1. Для КАЖДОГО типа проверить на дубликаты:

- Поиск типов с таким же названием во всем проекте
- Сравнение структуры полей с другими типами

2. Исключить указанные исключения (Events с разными суффиксами, DomainConfig, DomainConfigRawObj)

---

### Пункт 6: Все файлы должны использовать одинаковые отступы (2 пробела)

**Тип:** C (Полная файловая проверка)
**Описание:** Все файлы должны использовать одинаковые отступы (2 пробела)

**Алгоритм проверки:**

1. Отступы должны быть 2 пробела (не табы, не 4 пробела)

---

### Пункт 7: Все неиспользуемые импорты/экспорты должны быть удалены

**Тип:** C (Полная файловая проверка)
**Описание:** Все неиспользуемые импорты должны быть удалены
**Особые детали:**

- Нужно проверить каждый импорт по всем файлам проекта
- Исключение : this.em (private readonly em: EntityManager,)

**Алгоритм проверки:**

1. Для КАЖДОГО импорта проверить его использование в файле

---

### Пункт 8: Все функции должны иметь явные типы возвращаемых значений

**Тип:** C (Полная файловая проверка)
**Описание:** Все функции должны иметь явные типы возвращаемых значений
**Особые детали:**

- Исключение: async function bootstrap() -
- Исключения: bootstrap() в src/main.ts "Promises must be awaited…" - не считать ошибкой
- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как функция может быть многострочной и тип возвращаемого значения может быть на отдельной строке после параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с функциями (БЕЗ использования limit)
2. Проверить наличие явного типа возвращаемого значения для всей функции до закрывающей скобки
3. Исключить bootstrap()

---

### Пункт 9: Все параметры должны быть типизированы

**Тип:** C (Полная файловая проверка)
**Описание:** Все параметры должны быть типизированы
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как параметры функции могут быть многострочными

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с функциями (БЕЗ использования limit)
2. Проверить типизацию всех параметров до закрывающей скобки параметров

---

### Пункт 10: Все магические числа должны быть вынесены в константы

**Тип:** C (Полная файловая проверка)
**Описание:** Все магические числа должны быть вынесены в константы

**Алгоритм проверки:**

1. Найти магические числа (числа, не являющиеся константами)
2. Проверить, вынесены ли они в константы

---

### Пункт 11: Все новые поля имеющие @Field( должны иметь описания

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые поля имеющие @Field( должны иметь описания (@Field({ description: "..." })) но не до фанатизма, нет никакого смысла если понятие просто не нужно писать что-то типо 'email' : 'User email это само собой разумеющееся
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Field может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
2. Проверить наличие description в каждом новом @Field до закрывающей скобки декоратора

---

### Пункт 12: Ошибки должны быть типизированы (не просто string)

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки должны быть типизированы (не просто string)

**Алгоритм проверки:**

1. Найти обработку ошибок
2. Проверить типизацию ошибок (не просто string)

---

### Пункт 13: Не должно быть any типов

**Тип:** B (Простая проверка через grep)
**Описание:** Не должно быть any типов
**Особые детали:**

"- Исключение: @Payload() payload: Record<string, any>"

**Алгоритм проверки:**

1. Использовать grep для поиска `\bany\b` в измененных файлах
2. Исключить строки с исключениями
3. Проверить только изменения из коммита

---

### Пункт 14: Ошибки в сервисах: не бросать HTTP-исключения из сервисов; HTTP-слой в контроллерах

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки в сервисах: не бросать HTTP-исключения из сервисов; HTTP-слой в контроллерах

**Алгоритм проверки:**

1. Проверить, нет ли HTTP-исключений (BadRequestException, NotFoundException и т.д.) в сервисах
2. HTTP-исключения должны быть только в контроллерах

---

### Пункт 15: Группы и SSL Kafka: clientId, consumerGroupId, brokers, SSL-параметры — в config, отражены в env/helm

**Тип:** C (Полная файловая проверка)
**Описание:** Группы и SSL Kafka: clientId, consumerGroupId, brokers, SSL-параметры — в config, отражены в env/helm
**Особые детали:**

"- Исключения: 1) Отсутствует .helm директория, тогда не считать это ошибкой 2) DEBUG_PORT переменная"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в файлах конфигурации и helm
2. Проверить наличие Kafka параметров в config и helm файлах
3. Применить исключения

---

### Пункт 16: Валидация URL/методов: сверка всех прокси-методов

**Тип:** C (Полная файловая проверка)
**Описание:** Валидация URL/методов: сверка всех прокси-методов (например, deleteUploadedFiles → DELETE /v1.0/uploaded-files?ids=)"

**Алгоритм проверки:**

1. Проверить соответствие названия метода и HTTP-метода/URL

---

### Пункт 17: private readonly logger = new Logger(...) подобного в коде быть не должно в сервисах, в конструкторе нужно инджектить логгер

**Тип:** C (Полная файловая проверка)
**Описание:** private readonly logger = new Logger(CognitoService.name); подобного в коде быть (объявление new библиотек) не должно в сервисах в конструкторе нужно инджектить логгер

**Алгоритм проверки:**

1. Найти `new Logger(...)` - не должно быть
2. Логгер должен инджектиться через конструктор

---

### Пункт 18: Не должно быть console.log в продакшене

**Тип:** B (Простая проверка через grep)
**Описание:** Не должно быть console.log в продакшене
**Особые детали:**

"- Исключение: console.error('error.decoding.cursor.failed:', error);"

**Алгоритм проверки:**

1. Использовать grep для поиска `console\.log` в измененных файлах
2. Проверить найденные вхождения
3. Исключить console.error с указанным паттерном

---

### Пункт 19: Обязательные поля должны быть помечены как nullable: false

**Тип:** C (Полная файловая проверка)
**Описание:** Обязательные поля должны быть помечены как nullable: false

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в DTO/Entity
2. Проверить обязательные поля на наличие nullable: false

---

### Пункт 20: в package.json версия должны быть поднята

**Тип:** A (Глобальная проверка)
**Описание:** в package.json версия должны быть поднята например вместо 0.0.18 -> 0.0.19

**Алгоритм проверки:**

1. Проверить изменения в package.json
2. Если файл изменен, проверить изменение версии

---

### Пункт 21: в случае если есть entity наследованные от AggregateRoot обязательно должен быть параметр forceConstructor: true

**Тип:** C (Полная файловая проверка)
**Описание:** в случае если есть entity наследованные от AggregateRoot например export class CatchEntity extends AggregateRoot { обязательно должен быть параметр forceConstructor: true например @Entity({ tableName: 'catches', forceConstructor: true })"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Entity может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в entity
2. Читать файл ЦЕЛИКОМ для каждого измененного entity файла (БЕЗ использования limit)
3. Если entity extends AggregateRoot, проверить наличие forceConstructor: true в декораторе @Entity до закрывающей скобки

---

### Пункт 22: все переменные из .env-docker-compose-sample должны быть описаны в .helm/values.dev.yaml и .helm/values.production.yaml

**Тип:** C (Полная файловая проверка)
**Описание:** все переменные из .env-docker-compose-sample должны быть описаны в .helm/values.dev.yaml и .helm/values.production.yaml
**Особые детали:**

"- Исключение: Отсутствует .helm директория, тогда не считать это ошибкой"

- Исключение: POSTGRESQL_LOGS_ENABLED

**Алгоритм проверки:**

1. Проверить изменения в .env-docker-compose-sample или helm файлах
2. Сверить переменные между файлами
3. Применить исключения

---

### Пункт 23: Aggregate topics + headers: подписки на агрегатные топики, тип события только в header type"

**Тип:** C (Полная файловая проверка)
**Описание:** Aggregate topics + headers: подписки на агрегатные топики, тип события только в header type"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения связанные с Kafka/топиками
2. Проверить подписки на агрегатные топики и headers

---

### Пункт 24: plainToInstance везде должен содержать enableImplicitConversion: true

**Тип:** C (Полная файловая проверка)
**Описание:** plainToInstance везде должен содержать enableImplicitConversion: true пример: const result1 = plainToInstance(MyPayload, { prop: 1234 }, { enableImplicitConversion: true });"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как вызов plainToInstance может быть многострочным и третий параметр с enableImplicitConversion может быть на следующих строках после объекта данных

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с вызовами plainToInstance (БЕЗ использования limit)
2. Проверить наличие enableImplicitConversion: true в третьем параметре до закрывающей скобки вызова функции

---

### Пункт 25: uuid импорты для генерации должны проходить так: import { v7 as uuidv7 } from 'uuid'

**Тип:** B (Простая проверка через grep)
**Описание:** uuid импорты для генерации должны проходить так: import { v7 as uuidv7 } from 'uuid'; именно из этой библиотеки uuid, если где-то будет что-то такое import { uuidv7 } from 'uuidv7'; то это неправильно

**Алгоритм проверки:**

1. Использовать grep для поиска импортов uuid в измененных файлах:

```bash
"grep -r "from ['\"]uuid" src/ --include="*.ts""
```

2. Проверить формат импорта: должен быть `from 'uuid'` и `v7 as uuidv7`
3. НЕ должно быть `from 'uuidv7'`

---

### Пункт 26: ResponseDto классы всегда должны содержать @Exclude() перед объявлением а поля в нем @Expose()

**Тип:** C (Полная файловая проверка)
**Описание:** ResponseDto классы всегда должны содержать @Exclude() перед объявлением а поля в нем @Expose()
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком (декоратор на классе и декораторы на всех полях)

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного ResponseDto класса (БЕЗ использования limit)
2. Проверить наличие @Exclude() на классе
3. Проверить наличие @Expose() на всех полях класса

---

### Пункт 27: все @Property dto должны содержать следующий список полей type, name, nullable"

**Тип:** C (Полная файловая проверка)
**Описание:** все @Property dto должны содержать следующий список полей type, name, nullable пример: @Property({ type: 'string', name: 'location_title', nullable: true })"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Property может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
2. Проверить наличие всех полей type, name, nullable в декораторе @Property до закрывающей скобки

---

### Пункт 28: Все DTO должны содержать примеры для swagger и description

**Тип:** C (Полная файловая проверка)
**Описание:** Все DTO должны содержать примеры для swagger и description

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в DTO
2. Проверить наличие примеров и описаний для swagger

---

### Пункт 29: OpenAPI синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо

**Тип:** C (Полная файловая проверка)
**Описание:** OpenAPI синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в OpenAPI/Swagger конфигурации
2. Проверить актуальность схем и описаний

---

### Пункт 30: timestamp в базе должен везде быть with time zone (смотреть миграции)

**Тип:** C (Полная файловая проверка)
**Описание:** timestamp в базе должен везде быть with time zone (смотреть миграции)

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в миграциях
2. Проверить все timestamp на наличие "with time zone"

---

### Пункт 31: Отсутствие конструкторов в event-классах, создание через plainToInstance

**Тип:** C (Полная файловая проверка)
**Описание:** Отсутствие конструкторов в event-классах, создание через plainToInstance
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком на наличие конструктора

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в event-классах
2. Читать файл ЦЕЛИКОМ для каждого измененного event-класса (БЕЗ использования limit)
3. Проверить отсутствие конструкторов во всем классе
4. Проверить создание через plainToInstance

---

### Пункт 32: Все логи должны быть в формате lowercase с точками вместо пробелов

**Тип:** B (Простая проверка через grep)
**Описание:** Все логи должны быть в формате lowercase с точками вместо пробелов, переменные в конце отделены двоеточием. Пример: 'user.created.successfully: ${userId}' вместо 'User created successfully: ${userId}'"
**Особые детали:**

- lowercase - все буквы строчные
- через точки - слова разделены точками вместо пробелов
- переменные в конце - значения переменных после основного текста
- отделены двоеточием - между текстом и переменной стоит :
- для легкого поиска - можно искать по части строки

**Алгоритм проверки:**

1. Использовать grep для поиска строк логов в измененных файлах
2. Проверить формат: только lowercase, точки вместо пробелов, двоеточие перед переменными
3. Найти нарушения формата

---

### Пункт 33: (пустой пункт - пропускать)

---

### Пункт 34: В сервисах не должно быть создания экземпляров класса через New, по возможности либо @Inject либо plainToInstance"

**Тип:** C (Полная файловая проверка)
**Описание:** В сервисах не должно быть создания экземпляров класса через New, по возможности либо @Inject либо plainToInstance"
**Особые детали:**

"- КОНФИГ ЕСЛИ НУЖЕН В СЕРВИСЕ ДОЛЖЕН ИНЖЕКТИТЬСЯ @Inject(InfraConfig.KEY) private readonly config: ConfigType<typeof InfraConfig>, и потом использоваться так this.config.aws.cognito.userPoolId, и никак иначе

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как вызов new ClassName() может быть многострочным с параметрами"

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного сервиса (БЕЗ использования limit)
2. Найти `new ClassName()` - не должно быть (проверить весь вызов до закрывающей скобки)
3. Использовать @Inject или plainToInstance
4. Конфиг должен инджектиться через @Inject(InfraConfig.KEY)

---

### Пункт 35: tsconfig.json нужно чтобы было "target": "ES2024"

**Тип:** C (Полная файловая проверка)
**Описание:** tsconfig.json нужно чтобы было "target": "ES2024", и никакая другая
**Особые детали:**

- **КРИТИЧНО:** Читать файл tsconfig.json ЦЕЛИКОМ без limit для проверки конфигурации

**Алгоритм проверки:**

1. Проверить изменения в tsconfig.json
2. Если файл изменен, читать файл ЦЕЛИКОМ (БЕЗ использования limit) 3. Проверить target: "ES2024"

---

### Пункт 36: values.dev.yaml, values.production.yaml проверять синтаксис PARAM: VALUE через :

**Тип:** C (Полная файловая проверка)
**Описание:** values.dev.yaml, values.production.yaml проверять синтаксис например PARAM: VALUE через ":" должно быть не должно быть что-то типа PARAM=VALUE у меня такая ошибка часто бывала из-за копирования кода из env

**Алгоритм проверки:**

1. Проверить изменения в helm values файлах
2. Проверить синтаксис: должно быть PARAM: VALUE, а не PARAM=VALUE

---

### Пункт 37: Мутации и резолверы должны находиться в правильных каталогах

**Тип:** C (Полная файловая проверка)
**Описание:** Все GraphQL мутации должны находиться в каталоге mutations/, а резолверы в каталоге resolvers/. Не должно быть мутаций в каталоге resolvers/ и наоборот.

**Особые детали:**

- Мутации (классы с декоратором @Mutation) должны быть в каталоге `{module}/mutations/`
- Резолверы (классы с декоратором @Resolver, но без @Mutation) должны быть в каталоге `{module}/resolvers/`
- Если в модуле есть мутации, должен быть создан каталог `mutations/`
- Если в модуле есть резолверы, должен быть создан каталог `resolvers/`

**Алгоритм проверки:**

1. Извлечь ТОЛЬКО файлы с декораторами @Mutation или @Resolver
2. Для каждого файла с @Mutation проверить, что он находится в каталоге `*/mutations/*.ts`
3. Для каждого файла с @Resolver (без @Mutation) проверить, что он находится в каталоге `*/resolvers/*.ts`
4. Если в коммите создан новый файл с мутацией, проверить что каталог `mutations/` существует в соответствующем модуле
5. Если в коммите создан новый файл с резолвером, проверить что каталог `resolvers/` существует в соответствующем модуле

---

### Пункт 38: @Resolver() в классах с мутациями должен быть без типа, если нет @ResolveField()

**Тип:** C (Полная файловая проверка)
**Описание:** В классах с мутациями декоратор @Resolver() должен быть без параметра (типа). Тип может быть указан только если в том же классе есть @ResolveField() который использует @Parent() для доступа к полям parent объекта.

**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком на наличие @ResolveField()
- Если в классе есть только @Mutation() и нет @ResolveField() - @Resolver() должен быть без параметра: `@Resolver()`
- Если в классе есть @Mutation() И @ResolveField() с @Parent() - тогда @Resolver() может иметь тип: `@Resolver(() => SomeType)`
- Тип в @Resolver() указывает на родительский тип для @ResolveField()

**Алгоритм проверки:**

1. проверять только файлы с классами, содержащими @Mutation
2. Читать файл ЦЕЛИКОМ для каждого измененного файла с мутациями (БЕЗ использования limit)
3. Для каждого класса с @Mutation проверить:
   - Если в классе НЕТ методов с @ResolveField() - проверить, что @Resolver() без параметра
   - Если в классе ЕСТЬ методы с @ResolveField() и @Parent() - проверить, что @Resolver() имеет тип, соответствующий типу @Parent()
4. Найти все случаи, где @Resolver() имеет тип, но нет @ResolveField() в том же классе

---

### Пункт 39: В классах с мутациями слово "Resolver" допускается ТОЛЬКО в @Resolver и его импорте

**Тип:** B (Простая проверка через grep, только для GraphQL)
**Описание:** В классах, содержащих @Mutation, слово "Resolver" не должно встречаться нигде, кроме:

- импорта из `@nestjs/graphql` (строки вида `import { ..., Resolver, ... } from '@nestjs/graphql'`)
- строки с декоратором `@Resolver(...)`

Любые иные использования (имена классов/переменных/типов/комментарии и т.д.) запрещены.

**Алгоритм проверки:**

1. Найти все файлы в `*/mutations/*.ts`, содержащие `@Mutation(`
2. Для каждого такого файла выполнить поиск по регулярному выражению `\bresolver\b` с флагом `-i`
3. Отфильтровать допустимые строки:
   - начинающиеся с `import` и содержащие `Resolver` и `from '@nestjs/graphql'`
   - строки, содержащие `@Resolver(`
4. Если остаются иные вхождения — зафиксировать как нарушение

---

### Пункт 40: EnsureRequestContext требует entityManager в конструкторе

**Тип:** C (Полная файловая проверка)
**Описание:** Если в файле используется декоратор `EnsureRequestContext`, то в конструкторе класса должен быть параметр `entityManager` (или `EntityManager`). Это необходимо для обеспечения контекста запроса при работе с базой данных.

**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком
- Если в файле есть `EnsureRequestContext` (в любом месте - как декоратор на методе или классе), то в конструкторе должен быть параметр с именем `entityManager` или типом, содержащим `EntityManager`
- Проверка должна быть case-insensitive для имени параметра

**Алгоритм проверки:**

1. Для каждого файла проверить наличие `EnsureRequestContext` (через grep)
2. Если `EnsureRequestContext` найден, читать файл ЦЕЛИКОМ (БЕЗ использования limit)
3. Найти конструктор класса в этом файле
4. Проверить, что в параметрах конструктора есть:
   - Параметр с именем `entityManager` (case-insensitive) ИЛИ
   - Параметр с типом, содержащим `EntityManager`
5. Если `EnsureRequestContext` есть, но `entityManager` не найден в конструкторе - зафиксировать как нарушение

---

## GRAPHQL ПУНКТЫ (только для GraphQL проектов, пропускать для REST)

### Пункт 41: все input types для мутаций в graphql названия должны заканчиваться словами MutationInput либо SortInput

**Тип:** C (Полная файловая проверка)
**Описание:** все input types для мутаций в graphql названия должны заканчиваться словами MutationInput либо SortInput и никак иначе, проверять каждый файл отдельно нельзя использовать команды поиска типа find or grep

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL файлах
2. Найти новые input types для мутаций
3. Проверить окончание на MutationInput или SortInput

---

### Пункт 42: Не должно быть 2 резолверов с одинаковым названием в проекте

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть 2 резолверов с одинаковым названием в проекте например WaterbodyResolver должен быть только 1 и все поля waterbody структурно должны находиться там (хотя бы пустые в случае дальнейшего разолвинга отдельным резолвером)

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить дубликаты названий резолверов

---

### Пункт 43: все dataloader должны в схеме работать не заранее а если конкретное поле или свойство запрашивается

**Тип:** C (Полная файловая проверка)
**Описание:** все dataloader должны в схеме работать не заранее а если конкретное поле или свойство запрашивается например imagesCount -> если в запросе есть поле -> тогда оно и должно запрашиваться в dataloader а не на уровень выше

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL dataloader
2. Проверить логику работы dataloader

---

### Пункт 44: все классы заканчивающиеся на ConnectionArgs должны содержать extends ConnectionArgs

**Тип:** C (Полная файловая проверка)
**Описание:** все классы заканчивающиеся на ConnectionArgs должны содержать extends ConnectionArgs
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить всю декларацию класса

**Алгоритм проверки:**

1. анализировать ТОЛЬКО классы с окончанием ConnectionArgs
2. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
3. Проверить наличие extends ConnectionArgs в декларации класса

---

### Пункт 45: Используемые в mutation типы *MutationInput и если есть *MutationPayload должны объявляться в самом файле с мутацией

**Тип:** C (Полная файловая проверка)
**Описание:** Используемые в mutation типы *MutationInput и если есть *MutationPayload должны объявляться в самом файле с мутацией (если нужны свои типы, если MutationPayload пустой - понятное дело он будет родительский и в другом файле)"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL мутациях
2. Проверить объявление MutationInput и MutationPayload в том же файле

---

### Пункт 46: Все новые типы должны иметь описания (@ObjectType({ description: "..." }))

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые типы должны иметь описания (@ObjectType({ description: "..." }))
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @ObjectType может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. ТОЛЬКО @ObjectType декораторы
2. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
3. Проверить наличие description в каждом новом типе до закрывающей скобки декоратора

---

### Пункт 47: Все новые мутации должны иметь описания (@Mutation({ description: "..." }))

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые мутации должны иметь описания (@Mutation({ description: "..." }))
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Mutation может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. анализировать ТОЛЬКО @Mutation декораторы
2. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
3. Проверить наличие description в каждой новой мутации до закрывающей скобки декоратора

---

### Пункт 48: Все мутации должны возвращать MutationPayload с полем errors

**Тип:** C (Полная файловая проверка)
**Описание:** Все мутации должны возвращать MutationPayload с полем errors
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить всю сигнатуру функции мутации и тип возвращаемого значения

**Алгоритм проверки:**

1. анализировать ТОЛЬКО новые мутации
2. Читать файл ЦЕЛИКОМ для каждого измененного файла с мутациями (БЕЗ использования limit)
3. Проверить возвращаемый тип MutationPayload с полем errors во всей функции до закрывающей скобки

---

### Пункт 49: Все запросы к внешним сервисам должны использовать DataLoader

**Тип:** C (Полная файловая проверка)
**Описание:** Все запросы к внешним сервисам должны использовать DataLoader

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить использование DataLoader для запросов к внешним сервисам

---

### Пункт 50: Не должно быть N+1 проблем в резолверах

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть N+1 проблем в резолверах

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить на наличие N+1 проблем

---

### Пункт 51: Пагинация должна быть реализована через ConnectionArgs

**Тип:** C (Полная файловая проверка)
**Описание:** Пагинация должна быть реализована через ConnectionArgs

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL пагинации
2. Проверить использование ConnectionArgs

---

### Пункт 52: GraphQL синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо"

**Тип:** C (Полная файловая проверка)
**Описание:** GraphQL синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL схеме
2. Проверить актуальность схем и описаний

---

### Пункт 53: Ошибки: единый формат ошибок и маппинг на GraphQL MutationPayload.errors

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки: единый формат ошибок и маппинг на GraphQL MutationPayload.errors

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в обработке ошибок GraphQL
2. Проверить единый формат ошибок и маппинг

---

### Пункт 54: Пагинация/сортировка: единый формат ConnectionArgs, дефолты и лимиты"

**Тип:** C (Полная файловая проверка)
**Описание:** Пагинация/сортировка: единый формат ConnectionArgs, дефолты и лимиты"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL пагинации/сортировке
2. Проверить единый формат ConnectionArgs, дефолты и лимиты"

---
