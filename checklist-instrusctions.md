ОСНОВНЫЕ ПРАВИЛА

1. ЯЗЫК ОБЩЕНИЯ
   Отвечать ТОЛЬКО на русском языке

2. МЕТОД ПРОВЕРКИ КОДА - ОПТИМИЗИРОВАННЫЙ ПОДХОД
   РАЗРЕШЕНО и РЕКОМЕНДУЕТСЯ использовать команды поиска (grep, find, rg) для простых проверок и только для них
   Для сложных проверок использовать read_file и codebase_search
   Анализировать содержимое файлов детально, но только для измененных частей кода

3. ИСТОЧНИКИ ЧЕКЛИСТОВ

1) Получать содержимое чеклистов через curl (curl -sL ) из следующих URL:
   https://docs.google.com/spreadsheets/d/e/2PACX-1vT_8pz73L4Ku6Uz3qZBfCkndVcX7ORLYfZy46Peqm6nl3d0LD1dF4ckEmPaxjNBwywcHBgPvopX0fh9/pub?gid=1494972798&single=true&output=csv

   либо если при запуске команды был параметр reload=0 - получить содержимое тут .cursor/checklist.md

4. ОБРАБОТКА ЧЕКЛИСТОВ
   Каждый URL содержит пронумерованный список пунктов для проверки с детальной информацией о том, как нужно проверять
   Проверить ВСЕ пункты из ВСЕХ URL (сейчас только 1 url)

5. КЛАССИФИКАЦИЯ ПРОВЕРОК ПО ТИПАМ
   **ТИП A:** Глобальные проверки (выполнять 1 раз для всего проекта)
   **ТИП B:** Простые проверки через grep (для всех измененных файлов)
   **ТИП C:** Дифф-специфичные проверки (только изменения из коммита)
   **ТИП D:** Файловые проверки (для каждого измененного файла, только измененные части)
   **ТИП E:** Полные файловые проверки (читать файлы целиком БЕЗ лимита для многострочных конструкций)

6. ОПРЕДЕЛЕНИЕ ИЗМЕНЕНИЙ ИЗ КОММИТА
   ШАГ 1: Получить список файлов из коммита
   git log -1 --name-only --pretty=format: | grep -v '^$'

ШАГ 2: Для каждого файла получить ДИФФ (что именно изменилось)
git diff HEAD~1 HEAD -- [путь к файлу]
или для нового файла:
git show HEAD:[путь к файлу] (если файл новый)

ШАГ 3: Извлечь из диффа:

- Новые экспорты (export class, export interface, export type, export enum)

- Новые импорты (import ...)
- Измененные строки кода
- Новые функции/методы

ШАГ 4: Проверять ТОЛЬКО извлеченные изменения, а не весь файл

7. ОПТИМИЗИРОВАННЫЙ АЛГОРИТМ ПРОВЕРКИ

ШАГ 1: ПОДГОТОВКА

1. Получить инструкции из основного URL
2. Получить все чеклисты из всех URL
3. Объединить все пункты в один пронумерованный список
4. Определить список файлов из коммитов (последние N коммитов)
5. Получить git diff для каждого файла и сохранить ТОЛЬКО изменения

ШАГ 2: ГЛОБАЛЬНЫЕ ПРОВЕРКИ (ТИП A)

1. Запустить read_lints для всех измененных файлов ОДИН РАЗ
2. Вывести общий результат

ШАГ 3: ПРОСТЫЕ ПРОВЕРКИ (ТИП B)
Для каждого паттерна (русские комментарии, any, console.log, uuid):

1. Использовать grep для поиска в измененных файлах
2. Вывести найденные проблемы

ШАГ 4: ДИФФ-СПЕЦИФИЧНЫЕ ПРОВЕРКИ (ТИП C)
Для каждого измененного файла:

1. Извлечь из git diff только новые/измененные экспорты/типы/импорты
2. Проверить использование ТОЛЬКО этих новых элементов
3. НЕ проверять старые экспорты, которые уже были в файле

Пример для пункта 4 (неиспользуемые типы):

- В коммите добавлен только 1 новый export class NewType
- Проверить использование ТОЛЬКО NewType, а не всех 100 экспортов из файла
- Если NewType используется в других измененных файлах коммита - это ОК

ШАГ 5: ФАЙЛОВЫЕ ПРОВЕРКИ (ТИП D)
Для каждого измененного файла:

1. Анализировать ТОЛЬКО измененные строки из git diff
2. Читать файл полностью только если нужен контекст для понимания изменений
3. Проверять стиль кода только для новых/измененных частей

ШАГ 6: ПОЛНЫЕ ФАЙЛОВЫЕ ПРОВЕРКИ (ТИП E)
Для каждого измененного файла с пунктами типа E:

1. Читать файл ЦЕЛИКОМ без использования limit в read_file
2. Проверять многострочные конструкции полностью (функции, вызовы функций, декораторы с параметрами)
3. Убедиться, что проверяются все части многострочной конструкции до закрывающих скобок/скобок
4. Для конфигурационных файлов (tsconfig.json, package.json) читать полностью

5. УПРАВЛЕНИЕ ПРОЦЕССОМ
   После каждого URL останавливаться и спрашивать разрешение перейти к следующему
   "После каждого пункта НЕ останавливаться, но выводить результат"
   Перепроверять инструкцию после каждого пункта

6. ОБРАБОТКА GRAPHQL ПУНКТОВ
   Если пункт связан с GraphQL (Mutation, Query, Schema), но микросервис НЕ использует GraphQL - ПРОПУСТИТЬ пункт
   Перед началом проверок проанализировать: использует ли микросервис GraphQL схему или только REST

7. ТЕХНИЧЕСКИЕ ОГРАНИЧЕНИЯ
   НЕ врать о невозможности получить содержимое URL - они общедоступны
   Использовать только предоставленные инструменты

8. ОТЧЕТНОСТЬ
   Выводить результаты с маркерами: ✅ ПРОЙДЕН / ❌ НЕ ПРОЙДЕН для каждого пункта
   При этом если пункт пропущен - нужно писать и указывать причину пропуска
   В иноговом резельтате я хочу видеть все пункты

9. СТРОГИЕ ПРИНЦИПЫ
   НИКОГДА не делать предположений
   НИКОГДА не экстраполировать результаты
   НИКОГДА не использовать "вероятно", "скорее всего"
   ВСЕГДА проверять каждый случай отдельно
   НИКОГДА не врать и не обманывать

10. БАЛАНС МЕЖДУ ЭФФЕКТИВНОСТЬЮ И ТОЧНОСТЬЮ

- Для простых проверок использовать grep - это быстро и точно
- Для проверки использования новых элементов проверять только их, а не все из файла
- Читать файлы полностью только когда нужен контекст для сложных проверок
- Всегда проверять только изменения из коммита, а не весь проект

## ПРИМЕЧАНИЯ

- Для простых проверок (тип B) использовать grep
- Для глобальных проверок (тип A) выполнять один раз для всех файлов
- Для дифф-специфичных проверок (тип C) проверять только новые/измененные элементы
- Для файловых проверок (тип D) анализировать только измененные части кода
- Для полных файловых проверок (тип E) читать файлы ЦЕЛИКОМ без limit для многострочных конструкций
