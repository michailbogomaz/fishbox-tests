run command {commandName} {commandParams} ты должен выполянть команды либо выдать сообжение "неизвестная комманда" : {commandName} {command params}
список команд :

1. commandName = check
   commandParams
   commits=N - натуральное число больше 0 по умолчанию 1
   autofix=0 [0,1] - автоматически исправлять тривиальные проблемы (например, опечатки в ключах helm, target ES2024, формат uuid-импорта), по умолчанию 1
   files=LIST - необязательный список путей через запятую; если указан, проверять только эти файлы
   strict=1 [0,1] - 1: падать на первой критической ошибке; 0: собрать полный отчёт, по умолчанию 0
   checkOnlyNumbers - 1,2,3,4,5 массив который гововит какие пунты только проверять из чеклиста если 1,4,40 - только 1 3 и 40, если не присутствует - то проверять все пункты
   detailedReport=1 [0,1] - 1: формировать отдельные блоки отчётов по каждому пункту; 0: выводить только агрегированный результат без индивидуальных блоков, по умолчанию 1
   instructions = {instructions} постфикс файла инструкции по умолчанию 'fast'
   type=A[,B[,C]] - список типов проверок в требуемом порядке; по умолчанию выполняется только тип A. Нельзя переходить к следующему типу, пока предыдущий не завершён.

ПОВЕДЕНИЕ КОМАНДЫ CHECK:

- Сначала прочитай `.cursor/checklist-instrusctions_{instructions}.md`, зафиксируй подтверждение и выполни общие шаги подготовки.
- Далее для каждого типа из параметра `type` (по порядку):
  - прочитай файл `.cursor/checklist-instrusctions_{instructions}_type-{type}.md` и зафиксируй подтверждение;
  - используй связанный чеклист (`.cursor/checklist-type-a.md`, `.cursor/checklist-type-b.md`, `.cursor/checklist-type-c.md`);
  - выполни все пункты указанного типа; только после завершения переходи к следующему типу.
- Параметры команды влияют только на область и политику выполнения (files/commits/autofix/strict/type), но не переопределяют логику из чеклистов. Исключение — detailedReport=0, который включает упрощённый режим отчётности, описанный в инструкциях.

Примеры:
run command check commits=1
run command check commits=2 autofix=1 strict=0
run command check commits=1 autofix=1 strict=0 checkOnlyNumbers=11,7,8
run command check files=src/rating/rating.service.ts,src/rating/rating.controller.ts autofix=0
run command check commits=2 type=A,B,C strict=0 instructions=fast

2. commandName = pr
   commandParams:
   message={commit message} - сообщение коммита (необязательный)

ПОВЕДЕНИЕ КОМАНДЫ PR:

Создаёт pull request из текущей ветки в origin/main с одним squash-коммитом.

Алгоритм:

1. Определить текущую ветку (например, FBD-88 или FBD-88_5)
2. Извлечь базовое имя ветки (без суффикса \_N): FBD-88_5 → FBD-88, FBD-88 → FBD-88
3. Если message не указан:
   - Проанализировать изменения в ветке (git diff, изменённые файлы)
   - Сгенерировать краткое описание изменений на английском
   - Предложить пользователю: "Предлагаю сообщение: {сгенерированное}. Подтвердите или укажите своё."
   - Дождаться подтверждения или нового сообщения от пользователя
4. Найти все ветки вида {base}\_N (локально и в origin) и определить максимальный индекс N
   - Если веток с индексом нет — новый индекс = 1
   - Иначе — новый индекс = max(N) + 1
5. Создать новую ветку {base}\_N от origin/main (где N — новый индекс)
6. Выполнить `git merge --squash {исходная_ветка}`
7. Выполнить `git commit -m '{base} : {message}'`
8. Выполнить `git push origin {новая_ветка}`
9. Вывести ссылку для создания PR

Примеры:
run command pr message=Add entity catches aggregation endpoint
run command pr
