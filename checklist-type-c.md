## ПУНКТЫ ЧЕКЛИСТА (Тип C)

### Пункт 1: Вся бизнес логика должна быть в сервисах

**Тип:** C (Полная файловая проверка)
**Описание:** Вся бизнес логика должна быть в сервисах

**Алгоритм проверки:**

1. Проверить, нет ли бизнес-логики в контроллерах или других местах
2. Бизнес-логика должна быть только в сервисах

---

### Пункт 2: не должно быть создано пустых каталогов или типов/классов которые не используется в проекте

**Тип:** C (Полная файловая проверка)
**Описание:** не должно быть создано пустых каталогов или типов/классов которые не используется в проекте
**Особые детали:**

- Проверить ТОЛЬКО экспорты
- Исключить из проверки только файлы миграций (они используются MikroORM автоматически)
- ЗАПРЕЩЕНО останавливаться на первом найденном примере - проверить ВСЕ объявления

**Алгоритм проверки:**

1. Для КАЖДОГО нового экспорта проверить его использование:

- Импорты: `import { TypeName } from '...'`
- Использование в коде: `new TypeName()`, `TypeName.method()`

3. Исключить файлы миграций
4. Проверить использование ТОЛЬКО в измененных файлах коммита и во всем проекте
5. Составить список неиспользуемых ТОЛЬКО новых типов

---

### Пункт 3: Не должно быть типов с одинаковым названием или абсолютно одинаковым содержанием полей

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть типов с одинаковым названием или абсолютно одинаковым содержанием полей
**Особые детали:**

"- Исключение 1. Events - они должны быть разные - для например update delete, поэтому не считать например UserCreatedEvent и UserUpdatedEvent за ошибку"

- Исключение 2. DomainConfig
- Исключение 3. DomainConfigRawObj

**Алгоритм проверки:**

1. Для КАЖДОГО типа проверить на дубликаты:

- Поиск типов с таким же названием во всем проекте
- Сравнение структуры полей с другими типами

2. Исключить указанные исключения (Events с разными суффиксами, DomainConfig, DomainConfigRawObj)

---

### Пункт 4: Все файлы должны использовать одинаковые отступы (2 пробела)

**Тип:** C (Полная файловая проверка)
**Описание:** Все файлы должны использовать одинаковые отступы (2 пробела)

**Алгоритм проверки:**

1. Отступы должны быть 2 пробела (не табы, не 4 пробела)

---

### Пункт 5: Все неиспользуемые импорты/экспорты должны быть удалены

**Тип:** C (Полная файловая проверка)
**Описание:** Все неиспользуемые импорты должны быть удалены
**Особые детали:**

- Нужно проверить каждый импорт по всем файлам проекта
- Исключение : this.em (private readonly em: EntityManager,)

**Алгоритм проверки:**

1. Для КАЖДОГО импорта проверить его использование в файле

---

### Пункт 6: Все функции должны иметь явные типы возвращаемых значений

**Тип:** C (Полная файловая проверка)
**Описание:** Все функции должны иметь явные типы возвращаемых значений
**Особые детали:**

- Исключение: async function bootstrap() -
- Исключения: bootstrap() в src/main.ts "Promises must be awaited…" - не считать ошибкой
- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как функция может быть многострочной и тип возвращаемого значения может быть на отдельной строке после параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с функциями (БЕЗ использования limit)
2. Проверить наличие явного типа возвращаемого значения для всей функции до закрывающей скобки
3. Исключить bootstrap()

---

### Пункт 7: Все параметры должны быть типизированы

**Тип:** C (Полная файловая проверка)
**Описание:** Все параметры должны быть типизированы
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как параметры функции могут быть многострочными

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с функциями (БЕЗ использования limit)
2. Проверить типизацию всех параметров до закрывающей скобки параметров

---

### Пункт 8: Все магические числа должны быть вынесены в константы

**Тип:** C (Полная файловая проверка)
**Описание:** Все магические числа должны быть вынесены в константы

**Алгоритм проверки:**

1. Найти магические числа (числа, не являющиеся константами)
2. Проверить, вынесены ли они в константы

---

### Пункт 9: Все новые поля имеющие @Field( должны иметь описания

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые поля имеющие @Field( должны иметь описания (@Field({ description: "..." })) но не до фанатизма, нет никакого смысла если понятие просто не нужно писать что-то типо 'email' : 'User email это само собой разумеющееся
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Field может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
2. Проверить наличие description в каждом новом @Field до закрывающей скобки декоратора

---

### Пункт 10: Ошибки должны быть типизированы (не просто string)

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки должны быть типизированы (не просто string)

**Алгоритм проверки:**

1. Найти обработку ошибок
2. Проверить типизацию ошибок (не просто string)

---

### Пункт 11: Ошибки в сервисах: не бросать HTTP-исключения из сервисов; HTTP-слой в контроллерах

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки в сервисах: не бросать HTTP-исключения из сервисов; HTTP-слой в контроллерах

**Алгоритм проверки:**

1. Проверить, нет ли HTTP-исключений (BadRequestException, NotFoundException и т.д.) в сервисах
2. HTTP-исключения должны быть только в контроллерах

---

### Пункт 12: Группы и SSL Kafka: clientId, consumerGroupId, brokers, SSL-параметры — в config, отражены в env/helm

**Тип:** C (Полная файловая проверка)
**Описание:** Группы и SSL Kafka: clientId, consumerGroupId, brokers, SSL-параметры — в config, отражены в env/helm
**Особые детали:**

"- Исключения: 1) Отсутствует .helm директория, тогда не считать это ошибкой 2) DEBUG_PORT переменная"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в файлах конфигурации и helm
2. Проверить наличие Kafka параметров в config и helm файлах
3. Применить исключения

---

### Пункт 13: Валидация URL/методов: сверка всех прокси-методов

**Тип:** C (Полная файловая проверка)
**Описание:** Валидация URL/методов: сверка всех прокси-методов (например, deleteUploadedFiles → DELETE /v1.0/uploaded-files?ids=)"

**Алгоритм проверки:**

1. Проверить соответствие названия метода и HTTP-метода/URL

---

### Пункт 14: private readonly logger = new Logger(...) подобного в коде быть не должно в сервисах, в конструкторе нужно инджектить логгер

**Тип:** C (Полная файловая проверка)
**Описание:** private readonly logger = new Logger(CognitoService.name); подобного в коде быть (объявление new библиотек) не должно в сервисах в конструкторе нужно инджектить логгер

**Алгоритм проверки:**

1. Найти `new Logger(...)` - не должно быть
2. Логгер должен инджектиться через конструктор

---

### Пункт 15: Обязательные поля должны быть помечены как nullable: false

**Тип:** C (Полная файловая проверка)
**Описание:** Обязательные поля должны быть помечены как nullable: false

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в DTO/Entity
2. Проверить обязательные поля на наличие nullable: false

---

### Пункт 16: в случае если есть entity наследованные от AggregateRoot обязательно должен быть параметр forceConstructor: true

**Тип:** C (Полная файловая проверка)
**Описание:** в случае если есть entity наследованные от AggregateRoot например export class CatchEntity extends AggregateRoot { обязательно должен быть параметр forceConstructor: true например @Entity({ tableName: 'catches', forceConstructor: true })"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Entity может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в entity
2. Читать файл ЦЕЛИКОМ для каждого измененного entity файла (БЕЗ использования limit)
3. Если entity extends AggregateRoot, проверить наличие forceConstructor: true в декораторе @Entity до закрывающей скобки

---

### Пункт 17: все переменные из .env-docker-compose-sample должны быть описаны в .helm/values.dev.yaml и .helm/values.production.yaml

**Тип:** C (Полная файловая проверка)
**Описание:** все переменные из .env-docker-compose-sample должны быть описаны в .helm/values.dev.yaml и .helm/values.production.yaml
**Особые детали:**

"- Исключение: Отсутствует .helm директория, тогда не считать это ошибкой"

- Исключение: POSTGRESQL_LOGS_ENABLED

**Алгоритм проверки:**

1. Проверить изменения в .env-docker-compose-sample или helm файлах
2. Сверить переменные между файлами
3. Применить исключения

---

### Пункт 18: Aggregate topics + headers: подписки на агрегатные топики, тип события только в header type"

**Тип:** C (Полная файловая проверка)
**Описание:** Aggregate topics + headers: подписки на агрегатные топики, тип события только в header type"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения связанные с Kafka/топиками
2. Проверить подписки на агрегатные топики и headers

---

### Пункт 19: plainToInstance везде должен содержать enableImplicitConversion: true

**Тип:** C (Полная файловая проверка)
**Описание:** plainToInstance везде должен содержать enableImplicitConversion: true пример: const result1 = plainToInstance(MyPayload, { prop: 1234 }, { enableImplicitConversion: true });"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как вызов plainToInstance может быть многострочным и третий параметр с enableImplicitConversion может быть на следующих строках после объекта данных

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла с вызовами plainToInstance (БЕЗ использования limit)
2. Проверить наличие enableImplicitConversion: true в третьем параметре до закрывающей скобки вызова функции

---

### Пункт 20: ResponseDto классы всегда должны содержать @Exclude() перед объявлением а поля в нем @Expose()

**Тип:** C (Полная файловая проверка)
**Описание:** ResponseDto классы всегда должны содержать @Exclude() перед объявлением а поля в нем @Expose()
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком (декоратор на классе и декораторы на всех полях)

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного ResponseDto класса (БЕЗ использования limit)
2. Проверить наличие @Exclude() на классе
3. Проверить наличие @Expose() на всех полях класса

---

### Пункт 21: все @Property dto должны содержать следующий список полей type, name, nullable"

**Тип:** C (Полная файловая проверка)
**Описание:** все @Property dto должны содержать следующий список полей type, name, nullable пример: @Property({ type: 'string', name: 'location_title', nullable: true })"
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Property может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
2. Проверить наличие всех полей type, name, nullable в декораторе @Property до закрывающей скобки

---

### Пункт 22: Все DTO должны содержать примеры для swagger и description

**Тип:** C (Полная файловая проверка)
**Описание:** Все DTO должны содержать примеры для swagger и description

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в DTO
2. Проверить наличие примеров и описаний для swagger

---

### Пункт 23: OpenAPI синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо

**Тип:** C (Полная файловая проверка)
**Описание:** OpenAPI синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в OpenAPI/Swagger конфигурации
2. Проверить актуальность схем и описаний

---

### Пункт 24: timestamp в базе должен везде быть with time zone (смотреть миграции)

**Тип:** C (Полная файловая проверка)
**Описание:** timestamp в базе должен везде быть with time zone (смотреть миграции)

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в миграциях
2. Проверить все timestamp на наличие "with time zone"

---

### Пункт 25: Отсутствие конструкторов в event-классах, создание через plainToInstance

**Тип:** C (Полная файловая проверка)
**Описание:** Отсутствие конструкторов в event-классах, создание через plainToInstance
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком на наличие конструктора

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в event-классах
2. Читать файл ЦЕЛИКОМ для каждого измененного event-класса (БЕЗ использования limit)
3. Проверить отсутствие конструкторов во всем классе
4. Проверить создание через plainToInstance

---

### Пункт 26: (пустой пункт - пропускать)

---

### Пункт 27: В сервисах не должно быть создания экземпляров класса через New, по возможности либо @Inject либо plainToInstance"

**Тип:** C (Полная файловая проверка)
**Описание:** В сервисах не должно быть создания экземпляров класса через New, по возможности либо @Inject либо plainToInstance"
**Особые детали:**

"- КОНФИГ ЕСЛИ НУЖЕН В СЕРВИСЕ ДОЛЖЕН ИНЖЕКТИТЬСЯ @Inject(InfraConfig.KEY) private readonly config: ConfigType<typeof InfraConfig>, и потом использоваться так this.config.aws.cognito.userPoolId, и никак иначе

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как вызов new ClassName() может быть многострочным с параметрами"

**Алгоритм проверки:**

1. Читать файл ЦЕЛИКОМ для каждого измененного сервиса (БЕЗ использования limit)
2. Найти `new ClassName()` - не должно быть (проверить весь вызов до закрывающей скобки)
3. Использовать @Inject или plainToInstance
4. Конфиг должен инджектиться через @Inject(InfraConfig.KEY)

---

### Пункт 28: tsconfig.json нужно чтобы было "target": "ES2024"

**Тип:** C (Полная файловая проверка)
**Описание:** tsconfig.json нужно чтобы было "target": "ES2024", и никакая другая
**Особые детали:**

- **КРИТИЧНО:** Читать файл tsconfig.json ЦЕЛИКОМ без limit для проверки конфигурации

**Алгоритм проверки:**

1. Проверить изменения в tsconfig.json
2. Если файл изменен, читать файл ЦЕЛИКОМ (БЕЗ использования limit) 3. Проверить target: "ES2024"

---

### Пункт 29: values.dev.yaml, values.production.yaml проверять синтаксис PARAM: VALUE через :

**Тип:** C (Полная файловая проверка)
**Описание:** values.dev.yaml, values.production.yaml проверять синтаксис например PARAM: VALUE через ":" должно быть не должно быть что-то типа PARAM=VALUE

**Алгоритм проверки:**

1. Проверить изменения в helm values файлах
2. Проверить синтаксис: должно быть PARAM: VALUE, а не PARAM=VALUE

---

### Пункт 30: Мутации и резолверы должны находиться в правильных каталогах

**Тип:** C (Полная файловая проверка)
**Описание:** Все GraphQL мутации должны находиться в каталоге mutations/, а резолверы в каталоге resolvers/. Не должно быть мутаций в каталоге resolvers/ и наоборот.
**Особые детали:**

- Мутации (классы с декоратором @Mutation) должны быть в каталоге `{module}/mutations/`
- Резолверы (классы с декоратором @Resolver, но без @Mutation) должны быть в каталоге `{module}/resolvers/`
- Если в модуле есть мутации, должен быть создан каталог `mutations/`
- Если в модуле есть резолверы, должен быть создан каталог `resolvers/`

**Алгоритм проверки:**

1. Извлечь ТОЛЬКО файлы с декораторами @Mutation или @Resolver
2. Для каждого файла с @Mutation проверить, что он находится в каталоге `*/mutations/*.ts`
3. Для каждого файла с @Resolver (без @Mutation) проверить, что он находится в каталоге `*/resolvers/*.ts`
4. Если в коммите создан новый файл с мутацией, проверить что каталог `mutations/` существует в соответствующем модуле
5. Если в коммите создан новый файл с резолвером, проверить что каталог `resolvers/` существует в соответствующем модуле

---

### Пункт 31: @Resolver() в классах с мутациями должен быть без типа, если нет @ResolveField()

**Тип:** C (Полная файловая проверка)
**Описание:** В классах с мутациями декоратор @Resolver() должен быть без параметра (типа). Тип может быть указан только если в том же классе есть @ResolveField() который использует @Parent() для доступа к полям parent объекта.
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком на наличие @ResolveField()
- Если в классе есть только @Mutation() и нет @ResolveField() - @Resolver() должен быть без параметра
- Если в классе есть @Mutation() И @ResolveField() с @Parent() - тогда @Resolver() может иметь тип, соответствующий типу @Parent()
- Тип в @Resolver() указывает на родительский тип для @ResolveField()

**Алгоритм проверки:**

1. проверять только файлы с классами, содержащими @Mutation
2. Читать файл ЦЕЛИКОМ для каждого измененного файла с мутациями (БЕЗ использования limit)
3. Для каждого класса с @Mutation проверить:
   - Если в классе НЕТ методов с @ResolveField() - проверить, что @Resolver() без параметра
   - Если в классе ЕСТЬ методы с @ResolveField() и @Parent() - проверить, что @Resolver() имеет тип, соответствующий типу @Parent()
4. Найти все случаи, где @Resolver() имеет тип, но нет @ResolveField() в том же классе

---

### Пункт 32: EnsureRequestContext требует entityManager в конструкторе

**Тип:** C (Полная файловая проверка)
**Описание:** Если в файле используется декоратор `EnsureRequestContext`, то в конструкторе класса должен быть параметр `entityManager` (или `EntityManager`). Это необходимо для обеспечения контекста запроса при работе с базой данных.
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить весь класс целиком
- Если в файле есть `EnsureRequestContext` (в любом месте - как декоратор на методе или классе), то в конструкторе должен быть параметр с именем `entityManager` или типом, содержащим `EntityManager`
- Проверка должна быть case-insensitive для имени параметра

**Алгоритм проверки:**

1. Для каждого файла проверить наличие `EnsureRequestContext` (через grep)
2. Если `EnsureRequestContext` найден, читать файл ЦЕЛИКОМ (БЕЗ использования limit)
3. Найти конструктор класса в этом файле
4. Проверить, что в параметрах конструктора есть:
   - Параметр с именем `entityManager` (case-insensitive) ИЛИ
   - Параметр с типом, содержащим `EntityManager`
5. Если `EnsureRequestContext` есть, но `entityManager` не найден в конструкторе - зафиксировать как нарушение

---

## GRAPHQL ПУНКТЫ (только для GraphQL проектов, пропускать для REST)

### Пункт 33: все input types для мутаций в graphql названия должны заканчиваться словами MutationInput либо SortInput

**Тип:** C (Полная файловая проверка)
**Описание:** все input types для мутаций в graphql названия должны заканчиваться словами MutationInput либо SortInput и никак иначе, проверять каждый файл отдельно нельзя использовать команды поиска типа find or grep

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL файлах
2. Найти новые input types для мутаций
3. Проверить окончание на MutationInput или SortInput

---

### Пункт 34: Не должно быть 2 резолверов с одинаковым названием в проекте

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть 2 резолверов с одинаковым названием в проекте например WaterbodyResolver должен быть только 1 и все поля waterbody структурно должны находиться там (хотя бы пустые в случае дальнейшего разолвинга отдельным резолвером)

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить дубликаты названий резолверов

---

### Пункт 35: все dataloader должны в схеме работать не заранее а если конкретное поле или свойство запрашивается

**Тип:** C (Полная файловая проверка)
**Описание:** все dataloader должны в схеме работать не заранее а если конкретное поле или свойство запрашивается например imagesCount -> если в запросе есть поле -> тогда оно и должно запрашиваться в dataloader а не на уровень выше

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL dataloader
2. Проверить логику работы dataloader

---

### Пункт 36: все классы заканчивающиеся на ConnectionArgs должны содержать extends ConnectionArgs

**Тип:** C (Полная файловая проверка)
**Описание:** все классы заканчивающиеся на ConnectionArgs должны содержать extends ConnectionArgs
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить всю декларацию класса

**Алгоритм проверки:**

1. анализировать ТОЛЬКО классы с окончанием ConnectionArgs
2. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
3. Проверить наличие extends ConnectionArgs в декларации класса

---

### Пункт 37: Используемые в mutation типы *MutationInput и если есть *MutationPayload должны объявляться в самом файле с мутацией

**Тип:** C (Полная файловая проверка)
**Описание:** Используемые в mutation типы *MutationInput и если есть *MutationPayload должны объявляться в самом файле с мутацией (если нужны свои типы, если MutationPayload пустой - понятное дело он будет родительский и в другом файле)"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL мутациях
2. Проверить объявление MutationInput и MutationPayload в том же файле

---

### Пункт 38: Все новые типы должны иметь описания (@ObjectType({ description: "..." }))

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые типы должны иметь описания (@ObjectType({ description: "..." }))
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @ObjectType может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. ТОЛЬКО @ObjectType декораторы
2. Читать файл ЦЕЛИКОМ для каждого измененного файла (БЕЗ использования limit)
3. Проверить наличие description в каждом новом типе до закрывающей скобки декоратора

---

### Пункт 39: Все новые мутации должны иметь описания (@Mutation({ description: "..." }))

**Тип:** C (Полная файловая проверка)
**Описание:** Все новые мутации должны иметь описания (@Mutation({ description: "..." }))
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как декоратор @Mutation может быть многострочным с объектом параметров

**Алгоритм проверки:**

1. анализировать ТОЛЬКО @Mutation декораторы
2. Читать файл ЦЕЛИКОМ для каждого измененного файла с мутациями (БЕЗ использования limit)
3. Проверить наличие description в каждой новой мутации до закрывающей скобки декоратора

---

### Пункт 40: Все мутации должны возвращать MutationPayload с полем errors

**Тип:** C (Полная файловая проверка)
**Описание:** Все мутации должны возвращать MutationPayload с полем errors
**Особые детали:**

- **КРИТИЧНО:** Читать файл ЦЕЛИКОМ без limit, так как нужно проверить всю сигнатуру функции мутации и тип возвращаемого значения

**Алгоритм проверки:**

1. анализировать ТОЛЬКО новые мутации
2. Читать файл ЦЕЛИКОМ для каждого измененного файла с мутациями (БЕЗ использования limit)
3. Проверить возвращаемый тип MutationPayload с полем errors во всей функции до закрывающей скобки

---

### Пункт 41: Все запросы к внешним сервисам должны использовать DataLoader

**Тип:** C (Полная файловая проверка)
**Описание:** Все запросы к внешним сервисам должны использовать DataLoader

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить использование DataLoader для запросов к внешним сервисам

---

### Пункт 42: Не должно быть N+1 проблем в резолверах

**Тип:** C (Полная файловая проверка)
**Описание:** Не должно быть N+1 проблем в резолверах

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL резолверах
2. Проверить на наличие N+1 проблем

---

### Пункт 43: Пагинация должна быть реализована через ConnectionArgs

**Тип:** C (Полная файловая проверка)
**Описание:** Пагинация должна быть реализована через ConnectionArgs

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL пагинации
2. Проверить использование ConnectionArgs

---

### Пункт 44: GraphQL синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо"

**Тип:** C (Полная файловая проверка)
**Описание:** GraphQL синхронизация: актуальность схем и описаний, автогенерация клиентов где применимо"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL схеме
2. Проверить актуальность схем и описаний

---

### Пункт 45: Ошибки: единый формат ошибок и маппинг на GraphQL MutationPayload.errors

**Тип:** C (Полная файловая проверка)
**Описание:** Ошибки: единый формат ошибок и маппинг на GraphQL MutationPayload.errors

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в обработке ошибок GraphQL
2. Проверить единый формат ошибок и маппинг

---

### Пункт 46: Пагинация/сортировка: единый формат ConnectionArgs, дефолты и лимиты"

**Тип:** C (Полная файловая проверка)
**Описание:** Пагинация/сортировка: единый формат ConnectionArgs, дефолты и лимиты"

**Алгоритм проверки:**

1. Анализировать ТОЛЬКО изменения в GraphQL пагинации/сортировке
2. Проверить единый формат ConnectionArgs, дефолты и лимиты"

---
